/*
 * Timer0.c
 *
 * Created: 2/24/2023 1:35:06 PM
 *  Author: dell
 */ 

#include "Timer2_Interface.h"


//sets Tmer2 Config2s (Mode, interrupt)void TIMER2_SetConfig(void){	switch(Config2.Mode){		case NORMAL_MODE:			clearbit(TCCR2,TCCR2_WGM21);			clearbit(TCCR2,TCCR2_WGM20);						if(Config2.Enable_Interrupt == TIMER2_INT_ENABLE) setbit(TIMSK,TIMSK_TOIE2);			else clearbit(TIMSK,TIMSK_TOIE2);						break;					case PWM_PHASE_CORRECT:			clearbit(TCCR2,TCCR2_WGM21);			setbit(TCCR2,TCCR2_WGM20);			break;					case CTC_MODE:			setbit(TCCR2,TCCR2_WGM21);			clearbit(TCCR2,TCCR2_WGM20);			clearbit(TCCR2,TCCR2_COM20);			clearbit(TCCR2,TCCR2_COM21);									if(Config2.Enable_Interrupt == TIMER2_INT_ENABLE) setbit(TIMSK,TIMSK_OCIE2);			else clearbit(TIMSK,TIMSK_OCIE2);						break;		case FAST_PWM:			setbit(TCCR2,TCCR2_WGM21);			setbit(TCCR2,TCCR2_WGM20);			break;	}} //delay in milliseconds with blocking the cpu (busy wait)//if prescaler is 64 and Fcpu is 16MHz.. ticktime will be 4us..so we need 250 ticks to form 1ms//we need each timer cycle (overflow or compare match) to form 1ms.. then each cycle should be 250 ticks//number of milliseconds to be delayed is the number of cycles we need to perform void TIMER2_DelayMilliSeconds_with_Blocking(uint16 Milli_Seconds){		//for normal mode we load TCNT register with initial value 5 so each overflow is 250 ticks	if(Config2.Mode == NORMAL_MODE){		TCNT2 = 5;  //load TCNT with initial value		TCCR2 = (TCCR2 & PRESCALER_CLEAR) | PRESCALER_64;  //start timer with prescaler 64		while(Milli_Seconds > 0){			while(getbit(TIFR,TIFR_TOV2) == 0);			TCNT2 = 5;   //reload TCNT with initial value			setbit(TIFR,TIFR_TOV2);  //clear overflow flag			Milli_Seconds--;		}		TCCR2 &= PRESCALER_CLEAR;   //stop timer	}		//for CTC mode we load OCR register with 250 so each compare match is 250 ticks	else if(Config2.Mode == CTC_MODE){		OCR2 = 250;  //load OCR with compare match value		TCCR2 = (TCCR2 & PRESCALER_CLEAR) | PRESCALER_64;  //start timer with prescaler 64		while(Milli_Seconds > 0){			while(getbit(TIFR,TIFR_OCF2) == 0); //busy wait for compare match flag			setbit(TIFR,TIFR_OCF2); //clear compare match flag			Milli_Seconds--;		}		TCCR2 &= PRESCALER_CLEAR;   //stop timer	}}//delay in microseconds with blocking the cpu (busy wait)//if prescaler is 1 (no prescaler) and Fcpu is 16MHz.. ticktime will be 1/16us..so we need 16 ticks to form 1us//we need each timer cycle (overflow or compare match) to form 1us.. then each cycle should be 16 ticks//number of microseconds to be delayed is the number of cycles we need to performvoid TIMER2_DelayMicroSeconds_with_Blocking(uint16 Micro_Seconds){	//for normal mode we load TCNT register with initial value 239 so each overflow is 16 ticks	if(Config2.Mode == NORMAL_MODE){		TCNT2 = 239;  //load TCNT with initial value		TCCR2 = (TCCR2 & PRESCALER_CLEAR) | PRESCALER_1; //start timer with no prescaler		while(Micro_Seconds > 0){			while(getbit(TIFR,TIFR_TOV2) == 0); //busy wait for overflow flag			TCNT2 = 239;  //reload TCNT with initial value			setbit(TIFR,TIFR_TOV2); //clear overflow flag			Micro_Seconds--;		}		TCCR2 &= PRESCALER_CLEAR;  //stop timer	}		//for CTC mode we load OCR register with 16 so each compare match is 16 ticks	else if(Config2.Mode == CTC_MODE){		OCR2 = 16;  //load OCR with compare match value		TCCR2 = (TCCR2 & PRESCALER_CLEAR) | PRESCALER_1; //start timer with no prescaler		while(Micro_Seconds > 0){			while(getbit(TIFR,TIFR_OCF2) == 0); //busy wait for compare match flag			setbit(TIFR,TIFR_OCF2); //clear compare match flag			Micro_Seconds--;		}		TCCR2 &= PRESCALER_CLEAR; //stop timer	}}